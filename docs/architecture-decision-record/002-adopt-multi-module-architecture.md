# ADR 002: 시스템 확장성과 의존성 제어를 위한 멀티 모듈 구조 도입

DATE: 2025.05.01

## 상태 (Status)

Accepted

## 맥락 (Context)
[ADR-001](./001-adopt-domain-driven-design.md)에서 결정한 도메인 중심 설계를 기술적으로 강제하고, 트래픽 처리를 위한 확장성을 확보해야 한다. 단일 모듈(Monolith) 구조에서는 다음과 같은 문제가 예상된다.

1. 의존성 오염: 레이어드 아키텍처를 쓰더라도, 실수로 도메인 계층에서 웹(Web)이나 인프라(DB) 기술을 의존하는 것을 컴파일 레벨에서 막기 어렵다.
2. 배포 단위의 한계: 쿠폰 발급 요청을 받는 API 서버와, Kafka 메시지를 소비하는 워커(Consumer) 서버는 부하 특성이 다르다. 단일 모듈은 이 둘을 독립적으로 스케일 아웃(Scale-out)하기 어렵다.
3. 빌드 성능: 코드 일부 수정 시 전체 프로젝트를 다시 빌드해야 하므로 피드백 루프가 느려진다.

## 결정 (Decision)

우리는 Gradle 기반의 **멀티 모듈(Multi-Module) 아키텍처**를 도입하여 프로젝트를 물리적으로 분리한다.

### 모듈 구성

- `coupon-domain`: 도메인 엔티티와 순수 비즈니스 로직을 포함한다. (가장 내부에 위치, 외부 의존성 최소화)
- `coupon-api`: 사용자 트래픽을 처리하는 웹 계층이다. `coupon-domain`를 의존한다.
- `coupon-consumer`: Kafka 메시지를 비동기로 처리하는 워커 계층이다. `coupon-domain`를 의존한다.
- `support`: 로깅, 공통 유틸리티 등 범용 기능을 제공한다.

### 의존성 규칙

- `domain` 모듈은 `api`나 `consumer` 모듈의 존재를 알 수 없다 (단방향 의존성).
- 이를 통해 도메인 로직의 순수성을 보존하고 DIP(Dependency Inversion Principle)를 준수한다.

## 결과 (Consequences)

긍정적 효과 (Pros)
- 강제된 아키텍처: 잘못된 의존성 참조 시 컴파일 에러가 발생하여 아키텍처 원칙이 자동으로 지켜진다.
- 유연한 확장성: `coupon-api` 서버와 `coupon-consumer` 서버를 상황에 맞춰 개별적으로 증설하거나 배포할 수 있다. (예: 발급 요청 폭주 시 api 서버만 증설)
- 빌드 최적화: 변경된 모듈만 빌드하면 되므로 CI/CD 속도가 향상될 수 있다.

부정적 효과 및 트레이드오프 (Cons)
- 설정 복잡도 증가: `build.gradle` 설정이 모듈별로 나뉘어 관리가 까다로워질 수 있다.
- 버전 관리: 모듈 간 버전 싱크를 맞추는 데 주의가 필요하다.