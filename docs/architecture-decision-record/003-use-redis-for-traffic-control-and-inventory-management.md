# ADR 003: Redis를 활용한 고성능 트래픽 제어 및 재고 관리

DATE: 2025.05.07

## 상태 (Status)

Accepted

## 맥락 (Context)

선착순 이벤트 특성상 오픈 직후 수천~수만 TPS의 트래픽이 순간적으로 몰릴 것으로 예상된다.
이때 모든 요청에 대해 RDB를 조회하여 재고를 확인하고 중복 발급 여부를 검증한다면 다음과 같은 문제가 발생한다.

RDB 부하: `SELECT count(*)` 쿼리와 트랜잭션 경합으로 인해 DB CPU가 급증하고 커넥션 풀이 고갈된다.

응답 지연: 디스크 I/O 기반의 RDB는 메모리 기반 저장소보다 응답 속도가 느려, 사용자 경험(UX)을 저해한다.

따라서 DB에 도달하기 전 **앞단에서 트래픽을 효율적으로 제어하고 검증할 수 있는 캐싱 계층**이 필요하다.

## 결정 (Decision)

우리는 In-Memory Key-Value 저장소인 Redis를 도입하여 1차적인 트래픽 필터링을 수행한다.

1. Redis Set 자료구조를 이용한 중복 발급 검증:
    - 쿠폰 발급 요청 시 SADD key userId 명령어를 사용하여 유저의 ID를 저장한다.
    - Redis는 싱글 스레드 기반으로 동작하므로, 반환값이 1이면(신규) 통과, 0이면(이미 존재) 중복 요청으로 간주하여 즉시 거절한다.

2. Redis Incr 명령어를 이용한 실시간 재고 차감:
    - 쿠폰의 총수량을 Redis에 미리 적재해 두고, INCR (또는 DECR) 명령어를 통해 원자적(Atomic)으로 개수를 카운팅한다.
    - DB I/O 없이 메모리상에서 수량을 제어하므로 매우 빠른 응답 속도를 보장한다.

## 결과 (Consequences)

긍정적 효과 (Pros)
- 응답 속도 개선: 메모리 기반 연산으로 검증 로직을 밀리초(ms) 단위로 처리하여 대량의 트래픽을 감당할 수 있다.
- DB 보호: 유효하지 않은 요청(재고 초과, 중복 요청)이 DB까지 도달하지 않도록 막아주어 RDB의 부하를 최소화한다.

부정적 효과 및 트레이드오프 (Cons)
- 데이터 불일치 위험: Redis에서 재고 차감은 성공했으나, 네트워크 오류나 Consumer 장애로 인해 RDB에 발급 이력이 저장되지 않을 경우, Redis의 재고 카운트와 실제 DB의 발급 이력 개수가 일치하지 않을 수 있다.
- 메모리 데이터의 휘발성: Redis는 인메모리 저장소이므로, 예기치 못한 장애로 재시작될 경우 메모리에만 있던 실시간 재고 데이터가 유실될 수 있다. 이를 방지하기 위해 스냅샷이나 AOF 설정, 혹은 장애 복구 시 RDB의 이력 개수를 세어 Redis 재고를 복구하는 로직이 필요하다.
- 운영 복잡도: Redis 인프라를 추가로 관리해야 하며, Redis 관련 예외 처리를 애플리케이션 레벨에서 구현해야 한다.