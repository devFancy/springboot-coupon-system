# 쿠폰 발급 시스템 아키텍처 개선 과정 (V1 vs V2)

이 문서는 [분산 락 기반의 초기 아키텍처(V1)](./coupon-issuance-api-v1.md)에서 대기열 기반의 비동기 아키텍처(V2)로 발전하며 얻은 경험과 각 버전의 기술적인 차이점을 비교 분석합니다.

## V1과 V2의 핵심 아키텍처 차이

V1과 V2의 가장 큰 차이는 "누가, 그리고 언제 동시성 문제를 해결하고 부하를 제어하는가"에 있습니다.

- V1 (선착순 검증 모델): API 서버가 요청 시점에 **모든 검증(락 획득, 중복 체크, 수량 체크)을 직접 수행**하는 '게이트키퍼(Gatekeeper)' 역할을 합니다. 모든 요청이 이 좁은 문을 통과해야 하므로, 요청이 몰리면 API 서버 자체가 병목 이 될 수 있습니다.

- V2 (대기열 접수 모델): API 서버는 요청을 받자마자 **대기열(Redis Sorted Set)에 등록**만 하고 즉시 응답하는 '접수원(Receptionist)' 역할만 합니다. 실제 발급 처리는 별도의 스케줄러가 대기열의 요청을 제어 가능한 만큼 꺼내어 Kafka로 전달하고, 최종적으로 컨슈머가 처리합니다. 병목 지점을 시스템 후방으로 옮기고 분산시킨 구조입니다.


## 주요 변경점 상세 비교

### 1. 요청 처리 방식

- V1: 사용자가 `issue` API를 호출하면, 분산 락을 잡고, Redis에서 중복 여부와 수량을 확인한 뒤, Kafka에 메시지를 발행하는 과정 전체가 **API 서버의 요청 스레드 내에서 동기적으로 처리**됩니다. 사용자는 이 모든 과정이 끝날 때까지 기다려야 합니다.

- V2: 사용자가 `issue` API를 호출하면, API 서버는 Redis에 **대기열 등록과 입장 순번표(INCR) 발급**이라는 가벼운 작업만 수행하고 즉시 `202 Accepted` 와 유사한 성공 상태를 반환합니다. Kafka 발행 및 DB 저장 등 무거운 작업은 완전히 분리된 백그라운드 스레드(스케줄러, 컨슈머)에서 수행됩니다.

### 2. 동시성 제어 시점 및 전략

- V1: **API 서버 앞단**에서 모든 요청에 대해 `@DistributedLock`을 적용합니다. 10,000개의 요청이 동시에 들어오면 10,000개가 모두 락을 획득하기 위해 경쟁해야 하므로, 락 경합(Lock Contention)이 매우 심하고 성능 저하의 주된 원인이 됩니다.

- V2: **컨슈머 단계**에서 락을 적용합니다. 스케줄러가 대기열에서 100개씩만 요청을 꺼내 처리하도록 조절하므로, 컨슈머는 최대 100개의 제어된 트래픽에 대해서만 락을 처리하면 됩니다. 락 경합이 현저히 줄어들어 시스템 전체 성능이 향상됩니다.

### 3. 시스템 부하 제어

- V1: 별도의 부하 제어 장치가 없습니다. 들어오는 요청을 그대로 Kafka로 전달하므로, 순간적인 트래픽 폭증이 컨슈머와 DB에 그대로 전달되어 시스템 전체가 불안정해질 수 있습니다.

- V2: **스케줄러**가 '댐(Dam)' 역할을 합니다. 대기열(Redis)에 아무리 많은 요청이 쌓여도, 스케줄러가 정해진 주기(예: 1초)와 개수(예: 100개)만큼만 안정적으로 흘려보내므로 Kafka와 컨슈머, DB는 항상 감당 가능한 수준의 부하만 처리하게 됩니다.


## V1 vs V2 비교 요약표

| 구분 (Category) | V1 (동기 검증 기반) | V2 (대기열 기반 비동기) |
| --- | --- | --- |
| 핵심 전략 | 선검증, 후처리 (Validate-First) | 선접수, 후처리 (Queue-First) |
| API 서버 역할 | 게이트키퍼: 요청 검증, 락, Kafka 발행 등 **무거운 작업 수행** | 접수원: 대기열 등록 등 **가벼운 작업만 수행** 후 즉시 응답 |
| 응답 시간 | 비교적 김 (Redis 락/연산, Kafka 발행 시간 포함) | 매우 짧음 (Redis ZADD/INCR 연산만 수행) |
| 동시성 제어 | **API 서버**에서 분산 락 사용 (모든 요청이 락 경합) | **컨슈머**에서 분산 락 사용 (제어된 요청만 락 경합) |
| 시스템 부하 | 트래픽이 **DB/컨슈머에 직접 전달**되어 과부하 위험 | **스케줄러가 부하를 제어**하여 시스템 안정성 확보 |
| 확장성 | API 서버가 병목 지점이 되어 수평 확장에 한계 | API 서버, 스케줄러, 컨슈머 각각 독립적으로 확장 가능 |
| 주요 기술 | `@DistributedLock`, Redis `SADD`/`INCR`, Kafka Producer, Consumer | Redis `Sorted Set`/`INCR`, `@Scheduled`, Kafka Producer, Consumer |
